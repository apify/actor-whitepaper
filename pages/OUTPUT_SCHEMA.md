# Output Schema File

A JSON object that defines structure of the output generated by
actor (see [Input and Output](../README.md#input-and-output) for details).
The file is referenced from the main [actor file](ACTOR.md) using the `outputSchema` directive,
and it is typically stored in `.ACTOR/output_schema.json`.

**TODOs:**
- The output schema should enable developers to define schema for the 
  default dataset and key-value store. But how? It should be declaratively
  so that the system can check that e.g. the overridden default dataset
  has the right schema. But then, when it comes to kv-store, that's not purely
  output object but INPUT, similarly for overridden dataset or request queue.
  Perhaps the cleanest way would be to set these directly in `.ACTOR/actor.json`.

Note that the schema is not only used to generate UI, but also the output JSON object,
with fields corresponding to `properties`, whose values are API URLs to the data.
Such output object needs to be generated by system right when the actor starts,
and remain static over entire lifetime of actor.

## Structure

```json
{
  "actorOutputSchemaVersion": 1,
  "description": "Text that is shown in the Output UI",
  "properties": {
    // Default dataset contains all the scraped products
    // In the "output" object, the field should be a link to dataset with the right view
    "currentProducts": {
      "id": "@default",
      "type": "dataset",
      "schema": "./products_dataset_schema.json",
      "view": "productVariants"
    },

    // Actor uses named persistent request queue and named dataset to store all historical products
    // TODO JC: This shouldn't be fixed in output schema, the user might want to use different name record.
    //  In principal, I think output should only reference default storages, as that's
    //  something that URLs can be generated when the actor starts.
    "historicalProducts": {
      "id": "~historical-products",
      "type": "dataset",
      "schema": "./products_dataset_schema.json"
    },
    "historicalProductsQueue": {
      "id": "~historical-products",
      "type": "requestQueue"
      // Does not enforce a schema for this storage
    },

    // Selects a specific group of records with a certain prefix. In UI, this can be shown
    // as a list of images. In the output object, this will be a link to a API with "prefix" param.
    "productImages": {
      "title": "Product images",
      "type": "keyValueStore",
      "description": "Yaddada",
      "schema": "./product_images_key_value_store_schema.json",
      "recordGroup": "screenshots"
    },
    
    // In the output object, the result should be a link to the single KV-store file
    "summaryReportView": {
      "type": "keyValueStore.file",
      "schema": "./key_value_store_schema.json",
      "recordGroup": "monitoringReport"
    },

    // Live view
    // In the "output" object, the result should be a link to live view URL
    "apiServer": {
      "type": "liveView",
      // We should perhaps link a swagger file describing the API somehow?
      // JC: I don't think this is realistic, how would we even enforce the API schema?
      "schema": "TODO"
    }
  }
}
```

## Examples of ideal actor run UI

- For the majority of actors, we want to see the dataset with new records being added in realtime
- For [Google Spreadsheet Import](https://apify.com/lukaskrivka/google-sheets),
  we want to first display Live View for the user to set up OAUTH, and once 
   this is set up, then we want to display the log next time.
- For technical actors, it might be a log
- For [HTML to PDF convertor](https://apify.com/jancurn/url-to-pdf) it's a single record from key-value store
- For [Monitoring](https://apify.com/apify/monitoring-runner) it's log during the runtime and a single HTML record in an iframe in the end
- For an actor that has failed, it's the log
  (JC: Really? I'd want to see incomplete results. I can check log anytime)

## How to define actor run UI

### Simple version

There will be a new tab on actor run detail for every actor with output schema called "Output".
This tab will be at the first position and displayed by default. Tab will show the following:
- Items from output schema with property `visible: true` will be rendered in the same order
  as they are in schema
- The live view will be displayed only when it has `visible: true` and when it's active.
  Otherwise we should show just a short message "This show is over".
- If the dataset has more views then we should have some select or tabs to select the view

### Ideal most comprehensive state

- Default setup, i.e., what output components should be displayed at the default run tab
- Optionally, the setup for different states
- Be able to pragmatically changes this using API by actor itself

## TODOs
- Should we enforce users to have at least one item with `visible: true`? Or what about doing it the opposite
way and letting the user choose what should not be visible?
